{"version":3,"sources":["utils/pixiJs.ts","hooks/useTilesetsLoader.ts","components/pixi/Viewport.tsx","utils/isometric.ts","constants/tiles.ts","components/pixi/FloorTileLayer.tsx","components/Map/index.tsx","components/Modal/index.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["loadResource","path","callback","loader","PIXI","shared","resources","add","load","_","useTilesetsLoader","determineTilesetSpritesheetPath","useState","tilesetsTextures","setTilesets","data","setData","useEffect","console","log","nextTileset","nextTilesetToload","tilesetName","name","resource","error","Error","newTilesets","loadComplete","undefined","loadTilesets","value","tilesets","find","t","Viewport","forwardRef","props","ref","app","useApp","window","PixiComponentViewport","PixiComponent","create","viewport","PixiViewport","screenWidth","screenHeight","worldWidth","worldHeight","ticker","on","event","onClick","minScale","maxScale","drag","pinch","wheel","clamp","direction","clampZoom","decelerate","tileLocationToPosition","location","horizontalTiles","verticalTiles","x","TILE_WIDTH","y","require","FloorTileLayer","tilemap","CompositeRectTileLayer","texture","applyProps","instance","oldProps","layer","tileset","spritesheet","i","Math","floor","position","tile","tiles","id","firstgid","tileName","image","substr","lastIndexOf","addFrame","textures","length","innerWidth","innerHeight","Map","jsonPath","mapData","setMapData","ROUND_PIXELS","SCALE_MODE","SCALE_MODES","NEAREST","process","mapWidth","width","height","mapHeight","viewportRef","useRef","current","moveCenter","renderLayerTiles","tileData","layerIndex","map","gid","actualGid","findTileset","columns","flipVert","scale","split","textureName","warn","key","anchor","pivot","zIndex","options","sharedLoader","backgroundColor","parseBackgroundColor","backgroundcolor","className","firstTileGid","getTiles","Boolean","clearTextureCache","_texture","renderFloor","layers","l","draw","graphics","lineStyle","drawCircle","endFill","sortableChildren","filter","visible","index","tilesetData","asString","parseInt","substring","rawData","encoding","compression","Modal","onClose","handleClose","isOpen","ariaHideApp","portalClassName","overlayClassName","onRequestClose","src","App","currentMap","setCurrentMap","modalOpen","setModalOpen","handleOpen","setTimeout","onDoubleClick","onChange","e","currentTarget","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.3e763ec4.chunk.js","sourcesContent":["import { LoaderResource } from 'pixi.js';\nimport * as PIXI from 'pixi.js';\n\ninterface Location {\n    x: number;\n    y: number;\n}\n\nexport const lerpLocation = (point1: Location, point2: Location, alpha: number): Location => {\n    const x = lerp(point1.x, point2.x, alpha);\n    const y = lerp(point1.y, point2.y, alpha);\n    return { x, y };\n}\n\nconst lerp = (n1: number,  n2: number,  alpha: number) =>  {\n    return n1 + alpha * (n2 - n1);\n}\n\n// Uses the shared pixi loader to load a resource\nexport async function loadResourceAsync(path: string) { \n    const loader = PIXI.Loader.shared;\n    return new Promise<LoaderResource>((resolve, reject) => {\n        if (loader.resources[path]) {\n            resolve(loader.resources[path]);\n        }\n        else {\n            loader.add(path).load((_, resources) => {\n                resolve(resources[path]);\n            });\n        }\n    });\n}\n\nexport const loadResource = (path: string, callback: (resource: LoaderResource) => void) => { \n    const loader = PIXI.Loader.shared;\n    if (loader.resources[path]) {\n        callback(loader.resources[path]);\n        return;\n    }\n    loader.add(path).load((_, resources) => { callback(resources[path]!)});\n}","import { useState, useEffect } from \"react\";\nimport { TiledTilesetData } from \"utils/tiledMapData\";\nimport { loadResource } from \"utils/pixiJs\";\nimport { LoaderResource } from \"pixi.js\";\n\nconst useTilesetsLoader = (determineTilesetSpritesheetPath: (tileset: TiledTilesetData) => string) => {\n    const [tilesetsTextures, setTilesets] = useState<{[key: string]: LoaderResource}>({});\n    const [data, setData] = useState<TiledTilesetData[]>();\n\n    const loadTilesets = (value: TiledTilesetData[]) => {\n        setData(value);\n    };\n\n    useEffect(() => {\n        if (!data) return;\n        console.log('loading tilesets', data)\n        const nextTileset = nextTilesetToload(data, tilesetsTextures);\n        if (!nextTileset) return;\n\n        const tilesetName = nextTileset.name;\n        const path = determineTilesetSpritesheetPath(nextTileset);\n        loadResource(`${path}`, (resource) => {\n            if (resource.error) {\n                throw new Error(`Loading ${path}\\n${resource.error}`);\n            }\n            const newTilesets = { \n                ...tilesetsTextures,\n                [tilesetName]: resource\n            }\n            setTilesets(newTilesets);\n        });\n    }, [data, determineTilesetSpritesheetPath, tilesetsTextures]);\n    \n    const loadComplete = !!data && nextTilesetToload(data, tilesetsTextures) === undefined;\n\n    return {\n        loadComplete,\n        loadTilesets,\n        tilesetsTextures\n    }\n}\n\nexport default useTilesetsLoader;\n\n// Returns a TiledTilesetData that has not been loaded into tilesetsTextures yet\nconst nextTilesetToload = (tilesets: TiledTilesetData[], tilesetsTextures: {[key: string]: LoaderResource}) => {\n    return tilesets.find((t) => {\n        return !tilesetsTextures[t.name];\n    })\n}","import React, { forwardRef } from \"react\";\nimport { Viewport as PixiViewport, ClickEventData } from \"pixi-viewport\";\nimport { PixiComponent, useApp } from \"@inlet/react-pixi\";\nimport * as PIXI  from 'pixi.js';\n\ninterface Props {\n  onClick?(event: ClickEventData): void;\n  screenWidth: number,\n  screenHeight: number,\n  worldWidth: number,\n  worldHeight: number,\n  minScale?: number;\n  maxScale?: number;\n}\n\n/** Viewport leverages pixi-viewport to create a pannable map\n * https://davidfig.github.io/pixi-viewport/jsdoc/\n */\nconst Viewport = forwardRef<PixiViewport, any>((props, ref) => {\n  const app = useApp();\n  window.PIXI = PIXI;\n  //app.renderer.plugins.tilemap = require('pixi-tilemap');\n  // const cr = (PIXI as any).CanvasRenderer;\n  // if (cr) {\n  //     cr.registerPlugin('tilemap', pixi_tilemap.CanvasTileRenderer);\n  // }\n  \n  return <PixiComponentViewport app={app} {...props} ref={ref} />;\n})\n\ninterface PixiComponentProps {\n    app: PIXI.Application;\n}\n\nconst PixiComponentViewport = PixiComponent(\"Viewport\", {\n  create: (props: PixiComponentProps & Props) => {\n    const viewport = new PixiViewport({\n      screenWidth: props.screenWidth,\n      screenHeight: props.screenHeight,\n      worldWidth: props.worldWidth,\n      worldHeight: props.worldHeight,\n      ticker: props.app.ticker,\n      //interaction: props.app.renderer.plugins.interaction,\n      // the interaction module is important for wheel to work properly when renderer.view is placed or scaled\n    });\n    viewport.on(\"clicked\", (event) => { if(props.onClick) props.onClick(event) });\n\n    const {\n      minScale = .3,\n      maxScale = 1\n    } = props;\n\n    viewport\n      .drag()\n      .pinch()\n      .wheel()\n      .clamp({ direction: 'all' })\n      .clampZoom({ minScale, maxScale })\n      .decelerate();\n\n    return viewport;\n  }\n});\nexport default Viewport;\n","import * as PIXI from 'pixi.js';\nimport { TILE_WIDTH, TILE_HEIGHT, MARGIN_TOP } from \"constants/tiles\";\n\nexport const tileLocationToPosition = (location: [number, number], horizontalTiles: number, verticalTiles: number, ) => {\n  const originX = (verticalTiles - horizontalTiles) * (TILE_HEIGHT / 2) + ((verticalTiles + horizontalTiles) * TILE_WIDTH / 2) / 2;\n  const x = originX + (TILE_WIDTH / 2) * location[0] + (TILE_WIDTH / 2) * -location[1];\n  const y = (location[0] + location[1]) * TILE_HEIGHT / 2 + (TILE_HEIGHT) + MARGIN_TOP;\n  return new PIXI.Point(x, y);\n}","export const TILE_WIDTH = 128;\nexport const TILE_HEIGHT = 64;\nexport const MARGIN_TOP = 128;   // extra top margin around the map\n","import { PixiComponent } from \"@inlet/react-pixi\";\nimport * as PIXI  from 'pixi.js';\nimport { TiledLayerData, TiledTilesetData } from \"utils/tiledMapData\";\nimport { tileLocationToPosition } from \"utils/isometric\";\nimport { TILE_HEIGHT, TILE_WIDTH } from \"constants/tiles\";\nwindow.PIXI = PIXI;\nrequire('pixi-tilemap');\n\ninterface Props  {\n  texture: PIXI.Texture;\n  verticalTiles: number;\n  horizontalTiles: number;\n  layer: TiledLayerData;\n  tileset: TiledTilesetData;\n  spritesheet: PIXI.Spritesheet;\n};\n\n// Floortile layer leverages pixi-tilemap for better performance\nconst FloorTileLayer = PixiComponent<Props, any>(\"FloorTileLayer\", {\n  create(props: Props) {\n\n    // @ts-ignore\n    const tileLayer = new window.PIXI.tilemap.CompositeRectTileLayer(0, [props.texture]);\n    return tileLayer;\n  },\n\n  applyProps(instance, oldProps: Props, props: Props) {\n    const {layer, tileset, verticalTiles, horizontalTiles, spritesheet } = props;\n    if (!layer.data) {\n      return;\n    }\n    for (let i = 0; i < layer.data.length; i++) {\n      if (layer.data[i] > 0) {\n        const location: [number, number] = [i % horizontalTiles, Math.floor(i / horizontalTiles)];\n        const position = tileLocationToPosition(location, horizontalTiles, verticalTiles);\n\n        // @ts-ignore\n        const tile = tileset.tiles!.find((t) => t.id === layer.data[i] - tileset.firstgid);\n        const tileName = tile?.image.substr(tile?.image.lastIndexOf('/') + 1);\n        \n        instance.addFrame(spritesheet.textures[tileName!], \n          position.x - TILE_WIDTH / 2, \n          position.y - TILE_HEIGHT);\n      }\n    }\n  }\n});\n\nexport default FloorTileLayer;\n\n","import React, { useEffect, useState, useRef } from 'react';\nimport { loadResource } from 'utils/pixiJs';\nimport { Stage, Sprite, Container, Graphics } from '@inlet/react-pixi';\nimport { TiledMapData, TiledTilesetData, TiledLayerData } from 'utils/tiledMapData';\nimport * as PIXI from 'pixi.js';\nimport useTilesetsLoader from 'hooks/useTilesetsLoader';\nimport Viewport from '../pixi/Viewport';\nimport { SCALE_MODES } from 'pixi.js';\nimport { Viewport as PixiViewport } from \"pixi-viewport\";\nimport { TILE_HEIGHT, TILE_WIDTH, MARGIN_TOP} from 'constants/tiles';\nimport { tileLocationToPosition } from 'utils/isometric';\nimport FloorTileLayer from 'components/pixi/FloorTileLayer';\n\nconst screenWidth = window.innerWidth;\nconst screenHeight = window.innerHeight;\n\ninterface Props { \n  jsonPath: string\n}\n\n// // This stuff is needed for the pixi-js browser plugin\nif (process.env.NODE_ENV === \"development\") {\n  // @ts-ignore\n  // tslint:disable-next-line: no-unused-expression\n  window.__PIXI_INSPECTOR_GLOBAL_HOOK__ && window.__PIXI_INSPECTOR_GLOBAL_HOOK__.register({ PIXI });\n}\n\n\nconst Map = (props: Props) => {\n  const {jsonPath} = props;\n  const [mapData, setMapData] = useState<TiledMapData>();\n  PIXI.settings.ROUND_PIXELS = true;\n\n  const {\n    loadComplete,\n    loadTilesets,\n    tilesetsTextures\n  } = useTilesetsLoader(determineTilesetSpritesheetPath);\n\n  useEffect(() => {\n    PIXI.settings.SCALE_MODE = SCALE_MODES.NEAREST; // prevent lines on the edges of tiles\n    loadResource(`${process.env.PUBLIC_URL}/${jsonPath}`, (resource) => {\n      setMapData(resource.data);\n    });\n  }, [jsonPath]);\n\n  useEffect(() => {\n    console.log('mapdata changed', mapData)\n    if (mapData) {\n      loadTilesets(mapData.tilesets);\n    }\n  }, [loadTilesets, mapData]);\n\n  // https://stackoverflow.com/questions/4615116/how-to-calculate-the-height-and-width-of-an-isometric-rectangle-square\n  const mapWidth = ((mapData?.width || 1) + (mapData?.height || 1)) * (TILE_WIDTH / 2);\n  const mapHeight = ((mapData?.width || 1) + (mapData?.height || 1)) * (TILE_HEIGHT / 2) + MARGIN_TOP;\n\n  const viewportRef = useRef<PixiViewport>(null);\n  useEffect(() => {\n    // focus on center of the map\n    if (viewportRef.current && mapData) {\n        const viewport = viewportRef.current;\n        viewport.moveCenter(mapWidth / 2, mapHeight / 2);\n    }\n  }, [mapData, mapHeight, mapWidth]);\n\n\n  if (!loadComplete || !mapData) {\n    return (\n      <div>Loading...</div>\n    )\n  }\n\n  const renderFloor = (layer?: TiledLayerData) => {\n    if (!layer) {\n      console.warn(\"No layer with name 'floor' found!\");\n      return null;\n    }\n    const data = getTiles(layer);\n    const firstTileGid = data.find(Boolean);\n    if (!firstTileGid) {\n      console.warn(\"Layer with name 'floor' is empty?\");\n      return null;\n    }\n    const actualGid = firstTileGid & 0x1FFFFFFF;\n    const tileset = findTileset(actualGid, mapData!.tilesets);\n    if (!tileset) {\n      console.warn(\"No tileset found for floor layer. Huh?\");\n      return null;\n    }\n    const resource = tilesetsTextures[tileset.name];\n    PIXI.utils.clearTextureCache();\n\n    if (!resource.spritesheet) {\n      console.warn(`No texture loaded found for floor layer. Was looking for ${tileset.name}`);\n      return null;\n    }\n    return (\n      <FloorTileLayer \n        texture={(resource.spritesheet as any)._texture}\n        verticalTiles={mapData.height}\n        horizontalTiles={mapData.width}\n        layer={layer}\n        tileset={tileset}\n        spritesheet={resource.spritesheet}\n      />\n    )\n  }\n\n  const renderLayers = (layers: TiledLayerData[]) => {\n    return layers.filter(l => l.visible && l.name !== \"floor\").map((layer: TiledLayerData, index: number) => {\n      const data = getTiles(layer);\n      return (\n        // <Container key={layer.name} name={layer.name}>\n        renderLayerTiles(data, layer, index)\n        // </Container>\n      )  //people-transports/tile-people-transports-cart-01.png\n    });\n  } \n\n  const renderLayerTiles = (tileData: number[], layer: TiledLayerData, layerIndex: number) => {\n    return tileData.map((gid, i) => {\n      const actualGid = gid & 0x1FFFFFFF;\n      const tileset = findTileset(actualGid, mapData!.tilesets);\n      if (!tileset || !tileset.tiles || gid === 0) return null;\n\n      const columns = mapData!.width;\n      const x = (i % columns);\n      const y = Math.floor(i / columns);\n      \n      // See https://discourse.mapeditor.org/t/data-field-in-the-tmx-format-json/3633\n      const flipHor = (gid & 0x80000000) !== 0;\n      const flipVert = (gid & 0x40000000) !== 0;\n      // const flipDiag = (gid & 0x20000000) !== 0;\n      const scale: [number, number] = [1, 1];\n      if (flipHor) {\n        scale[0] *= -1;\n      }\n      if (flipVert) {\n        scale[1] *= -1;\n      }\n      const texture = tileset.tiles.find((t) => t.id === actualGid - tileset.firstgid);\n      if (!texture) return null;\n\n      // the image is in the format \"tiles/structure-wall/tile-structure-wall-gray-left.png\"\n      // the 'structure-wall' part refers to the spritesheet, the 'tile-structure-wall-gray-left' is the texture on the spriesheet\n      const [\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        _,\n        spritesheet,\n        textureName\n      ] = texture.image.split(\"/\");\n      if (!tilesetsTextures[spritesheet]) {\n        console.warn(`Could not find spritesheet ${spritesheet} ${tilesetsTextures}`);\n      };\n      if (!tilesetsTextures[spritesheet].textures![textureName]) {\n        console.warn(`Could not find texture ${spritesheet} ${textureName}`);\n      }\n\n      return (\n          <Sprite\n            key={i}\n            name={`${layer.name}: ${x},${y} (${textureName})`}\n            scale={scale}\n            texture={tilesetsTextures[spritesheet].textures![textureName]}\n            anchor={[0, 1]}\n            pivot={[TILE_WIDTH / 2, 0]}\n            position={tileLocationToPosition([x, y], mapData.width, mapData.height)}\n            zIndex={i * 100 + layerIndex}\n          /> \n      );  \n    })\n  }\n\n  const options = { \n    sharedLoader: true,\n    backgroundColor: parseBackgroundColor(mapData?.backgroundcolor)\n  }\n\n  return (\n    <Stage width={screenWidth} height={screenHeight} className=\"background\" options={options}>\n      <Viewport\n        worldWidth={mapWidth}\n        worldHeight={mapHeight}\n        screenWidth={screenWidth}\n        screenHeight={screenHeight}\n        ref={viewportRef}\n      >\n        {renderFloor(mapData.layers.find(l => l.name === \"floor\"))}\n        <Graphics\n            name=\"selectioncircle\"\n            draw={graphics => {\n                const line = 3;\n                graphics.lineStyle(line, 0xFFFFFF);\n                graphics.drawCircle(0, 0, 5);\n                graphics.endFill();\n            }}\n            position={tileLocationToPosition([0, 0], mapData.width, mapData.height)}\n\n        />\n        <Container sortableChildren={true}>\n          {renderLayers(mapData.layers)}\n        </Container>\n      </Viewport>\n    </Stage>\n  );\n}\n\nexport default Map;\n// returns the path to the spritesheet for given tileset\nconst determineTilesetSpritesheetPath = (tilesetData: TiledTilesetData) => `${process.env.PUBLIC_URL}/maps/tilesets/${tilesetData.name}.json`;\n\n// finds tileset based on gid\nconst findTileset = (gid: number, tilesets: TiledTilesetData[]) => {\n  let tileset;\n  for (let i = tilesets.length - 1; i >= 0; i--) {\n    tileset = tilesets[i];\n    if (tileset.firstgid <= gid) {\n      break;\n    }\n  }\n  return tileset;\n}\n\nconst parseBackgroundColor = (asString: string | undefined) : number | undefined => {\n  if (!asString) { return; }\n  return parseInt(asString.substring(1), 16); // strip the hash, conver to int\n}\n\nconst getTiles = (layer: TiledLayerData): number[] => {\n\n    let data = null;\n    let rawData = layer.data;\n\n    if (typeof(rawData) !== 'string') {\n      // return new Uint8Array(rawData);\n      return rawData;\n    }\n\n    // ==================================\n    // == If applicable, decode Base64 ==\n    // ==================================\n    if(layer.encoding === 'base64') {\n        // data = base64.decode(rawData);\n        // data = base64.decode(\"dGVzdA==\");\n    }\n\n    // ============================================\n    // == If applicable, extract compressed data ==\n    // ============================================\n    if(layer.compression === 'gzip') {\n    //    data = zlib.gunzipSync(data);\n    }\n\n    // ====================================\n    // == Read buffer data every 4 bytes ==\n    // ====================================\n\n    // Each 32-bit integer is placed in an 8-bit integer array.\n    // There will never be a tile ID greater than 255, so only 1 byte is required.\n    // let array = new Uint8Array(layer.width * layer.height);\n    // for(let i=0, index=0; i<data.length; i += 4, index++) {\n    //     array[index] = data.readUInt32LE(i);\n    //     index++;\n    // }\n    // return array;\n    return [];\n}","import React from 'react';\nimport ReactModal from 'react-modal';\nimport './styles/modal.css';\n\n\ninterface Props {\n  onClose: () => void;\n}\n\nconst Modal = (props: Props) => {\n  const { onClose} = props;\n\n  const handleClose = () => {\n    onClose();\n  };\n\n\n  return (\n    <ReactModal\n      isOpen={true}\n      ariaHideApp={false}\n      portalClassName=\"modal-portal\"\n      overlayClassName=\"modal-overlay\"\n      className=\"modal\"\n      onRequestClose={handleClose}\n    >\n      <>\n        <div className=\"header\">\n          <h1>TEST </h1>\n          <div className=\"modal-close\" onClick={() => handleClose()}></div>\n        </div>\n        <iframe src=\"https://21cceducation.nl/content/webgl_portfolio/games/ConveyorGame/\"></iframe>\n      </>\n    </ReactModal>  \n  )\n}\n\nexport default Modal;\n\n","import React, { useState, useEffect } from 'react';\nimport './App.css';\nimport Map from \"./components/Map\";\nimport Modal from 'components/Modal';\n\n\nfunction App() {\n  const [currentMap, setCurrentMap] = useState(\"maps/testmap3.json\");\n  const [modalOpen, setModalOpen] = useState(false);\n\n  const handleClose = () => {\n    setModalOpen(false)\n  }\n  const handleOpen = () => {\n    setModalOpen(true)\n  }\n\n  useEffect(() => {\n    setTimeout(handleOpen, 5000);\n  }, []);\n  return (\n    <div className=\"App\" onDoubleClick={handleOpen}>\n      <select value={currentMap} onChange={e => setCurrentMap(e.currentTarget.value)}>\n        <option>maps/testmap1.json</option>\n        <option>maps/testmap2.json</option>\n        <option>maps/testmap3.json</option>\n        <option>maps/testmap4.json</option>\n      </select>\n      {modalOpen && <Modal onClose={handleClose} />  }\n      <Map jsonPath={currentMap} />\n        {/* <Stage width={mapWidth} height={mapHeight} options={{backgroundColor: 0x0}} className=\"background\">\n            {textures && (\n              <>\n                <Sprite\n                  texture={textures[\"tile-structure-floor-blackwhite.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([0, 0])}\n                /> \n                <Sprite\n                  texture={textures[\"tile-structure-floor-blackwhite.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([1, 0])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-blackwhite.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([2, 0])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-blackwhite.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([3, 0])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-dadada.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([4, 0])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-blackwhite.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([5, 0])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-dadada.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([0, 1])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-wood.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([1, 1])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-blackwhite.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([2, 1])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([3, 1])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([4, 1])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([5, 1])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([0, 2])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([1, 2])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([2, 2])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([3, 2])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([4, 2])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([5, 2])}\n                />\n              </> \n            )}\n\n        </Stage> */}\n        </div>\n  );\n}\n\nexport default App;\n\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
{"version":3,"sources":["utils/pixiJs.ts","hooks/useTilesetsLoader.ts","components/Viewport.tsx","components/Map/index.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["loadResource","path","callback","loader","PIXI","shared","resources","add","load","_","useTilesetsLoader","determineTilesetSpritesheetPath","useState","tilesetsTextures","setTilesets","data","setData","useEffect","nextTileset","nextTilesetToload","tilesetName","name","resource","error","console","newTilesets","textures","loadComplete","undefined","loadTilesets","value","tilesets","find","t","Viewport","forwardRef","props","ref","app","useApp","PixiComponentViewport","PixiComponent","create","viewport","PixiViewport","screenWidth","screenHeight","worldWidth","worldHeight","ticker","on","event","onClick","minScale","maxScale","drag","pinch","wheel","clamp","direction","clampZoom","decelerate","Map","jsonPath","mapData","setMapData","SCALE_MODE","SCALE_MODES","NEAREST","process","tileLocationToPosition","location","x","width","y","mapWidth","mapHeight","height","viewportRef","useRef","current","moveCenter","log","renderLayerTiles","tileData","map","gid","i","tileset","findTileset","tiles","columns","Math","floor","texture","id","firstgid","image","split","spritesheet","textureName","warn","key","anchor","pivot","TILE_WIDTH","position","className","options","sharedLoader","backgroundColor","layers","filter","l","visible","layer","tilesetData","length","App","currentMap","setCurrentMap","onChange","e","currentTarget","Boolean","window","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.636588a2.chunk.js","sourcesContent":["import { LoaderResource } from 'pixi.js';\nimport * as PIXI from 'pixi.js';\n\ninterface Location {\n    x: number;\n    y: number;\n}\n\nexport const lerpLocation = (point1: Location, point2: Location, alpha: number): Location => {\n    const x = lerp(point1.x, point2.x, alpha);\n    const y = lerp(point1.y, point2.y, alpha);\n    return { x, y };\n}\n\nconst lerp = (n1: number,  n2: number,  alpha: number) =>  {\n    return n1 + alpha * (n2 - n1);\n}\n\n// Uses the shared pixi loader to load a resource\nexport async function loadResourceAsync(path: string) { \n    const loader = PIXI.Loader.shared;\n    return new Promise<LoaderResource>((resolve, reject) => {\n        if (loader.resources[path]) {\n            resolve(loader.resources[path]);\n        }\n        else {\n            loader.add(path).load((_, resources) => {\n                resolve(resources[path]);\n            });\n        }\n    });\n}\n\nexport const loadResource = (path: string, callback: (resource: LoaderResource) => void) => { \n    const loader = PIXI.Loader.shared;\n    if (loader.resources[path]) {\n        callback(loader.resources[path]);\n        return;\n    }\n    loader.add(path).load((_, resources) => { callback(resources[path]!)});\n}","import { useState, useEffect } from \"react\";\nimport { TiledTilesetData } from \"../utils/tiledMapData\";\nimport { loadResource } from \"../utils/pixiJs\";\n\nconst useTilesetsLoader = (determineTilesetSpritesheetPath: (tileset: TiledTilesetData) => string) => {\n    const [tilesetsTextures, setTilesets] = useState<{[key: string]: PIXI.ITextureDictionary}>({});\n    const [data, setData] = useState<TiledTilesetData[]>();\n\n    const loadTilesets = (value: TiledTilesetData[]) => {\n        setData(value);\n    };\n\n    useEffect(() => {\n        if (!data) return;\n        const nextTileset = nextTilesetToload(data, tilesetsTextures);\n        if (!nextTileset) return;\n\n        const tilesetName = nextTileset.name;\n        const path = determineTilesetSpritesheetPath(nextTileset);\n        loadResource(`${path}`, (resource) => {\n            if (resource.error) {\n                console.error(resource.error);\n            }\n            const newTilesets = { \n                ...tilesetsTextures,\n                [tilesetName]: resource.textures!\n            }\n            setTilesets(newTilesets);\n        });\n    }, [data, determineTilesetSpritesheetPath, tilesetsTextures]);\n    \n    const loadComplete = !!data && nextTilesetToload(data, tilesetsTextures) === undefined;\n\n    return {\n        loadComplete,\n        loadTilesets,\n        tilesetsTextures\n    }\n}\n\nexport default useTilesetsLoader;\n\n// Returns a TiledTilesetData that has not been loaded into tilesetsTextures yet\nconst nextTilesetToload = (tilesets: TiledTilesetData[], tilesetsTextures: {[key: string]: PIXI.ITextureDictionary}) => {\n    return tilesets.find((t) => {\n        return !tilesetsTextures[t.name];\n    })\n}","import React, { forwardRef } from \"react\";\nimport { Viewport as PixiViewport, ClickEventData } from \"pixi-viewport\";\nimport { PixiComponent, useApp } from \"@inlet/react-pixi\";\n\ninterface Props {\n  onClick?(event: ClickEventData): void;\n  screenWidth: number,\n  screenHeight: number,\n  worldWidth: number,\n  worldHeight: number,\n  minScale?: number;\n  maxScale?: number;\n}\n\n/** Viewport leverages pixi-viewport to create a pannable map\n * https://davidfig.github.io/pixi-viewport/jsdoc/\n */\nconst Viewport = forwardRef<PixiViewport, any>((props, ref) => {\n  const app = useApp();\n  return <PixiComponentViewport app={app} {...props} ref={ref} />;\n})\n\ninterface PixiComponentProps {\n    app: PIXI.Application;\n}\n\nconst PixiComponentViewport = PixiComponent(\"Viewport\", {\n  create: (props: PixiComponentProps & Props) => {\n    const viewport = new PixiViewport({\n      screenWidth: props.screenWidth,\n      screenHeight: props.screenHeight,\n      worldWidth: props.worldWidth,\n      worldHeight: props.worldHeight,\n      ticker: props.app.ticker,\n      //interaction: props.app.renderer.plugins.interaction,\n      // the interaction module is important for wheel to work properly when renderer.view is placed or scaled\n    });\n    viewport.on(\"clicked\", (event) => { if(props.onClick) props.onClick(event) });\n\n    const {\n      minScale = .5,\n      maxScale = 1\n    } = props;\n\n    viewport\n      .drag()\n      .pinch()\n      .wheel()\n      .clamp({ direction: 'all' })\n      .clampZoom({ minScale, maxScale })\n      .decelerate();\n\n    return viewport;\n  }\n});\nexport default Viewport;\n","import React, { useEffect, useState, useRef } from 'react';\nimport { loadResource } from '../../utils/pixiJs';\nimport { Stage, Sprite, Container } from '@inlet/react-pixi';\nimport { TiledMapData, TiledTilesetData, TiledLayerData } from '../../utils/tiledMapData';\nimport { SpritesheetData, SpriteData } from '../../utils/spritesheetData';\nimport * as PIXI from 'pixi.js';\nimport useTilesetsLoader from '../../hooks/useTilesetsLoader';\nimport Viewport from '../Viewport';\nimport { SCALE_MODES } from 'pixi.js';\nimport { Viewport as PixiViewport } from \"pixi-viewport\";\n\nconst TILE_WIDTH = 128;\nconst TILE_HEIGHT = 64;\nconst MARGIN_TOP = 128;   // extra top margin around the map\n\nconst screenWidth = 1280;\nconst screenHeight = 720;\n\ninterface Props { \n    jsonPath: string\n}\n\n// // This stuff is needed for the pixi-js browser plugin\nif (process.env.NODE_ENV === \"development\") {\n  // @ts-ignore\n  // tslint:disable-next-line: no-unused-expression\n  window.__PIXI_INSPECTOR_GLOBAL_HOOK__ && window.__PIXI_INSPECTOR_GLOBAL_HOOK__.register({ PIXI });\n}\n\n\nconst Map = (props: Props) => {\n  const {jsonPath} = props;\n  const [mapData, setMapData] = useState<TiledMapData>();\n\n  const {\n    loadComplete,\n    loadTilesets,\n    tilesetsTextures\n  } = useTilesetsLoader(determineTilesetSpritesheetPath);\n\n  useEffect(() => {\n    PIXI.settings.SCALE_MODE = SCALE_MODES.NEAREST; // prevent lines on the edges of tiles\n    loadResource(`${process.env.PUBLIC_URL}/${jsonPath}`, (resource) => {\n      setMapData(resource.data);\n    });\n  }, [jsonPath]);\n\n  useEffect(() => {\n    if (mapData) {\n      loadTilesets(mapData.tilesets);\n    }\n  }, [loadTilesets, mapData]);\n\n\n  const tileLocationToPosition = (location: [number, number]) => {\n    const x = (location[0] - location[1]) * TILE_WIDTH / 2 + (TILE_WIDTH * mapData!.width / 2);\n    const y = (location[0] + location[1]) * TILE_HEIGHT / 2 + (TILE_HEIGHT) + MARGIN_TOP;\n    return new PIXI.Point(x, y);\n  }\n\n  const mapWidth = TILE_WIDTH * (mapData?.width || 1);\n  const mapHeight = TILE_HEIGHT * (mapData?.height || 1) + MARGIN_TOP;\n\n  const viewportRef = useRef<PixiViewport>(null);\n  useEffect(() => {\n    // focus on center of the map\n    if (viewportRef.current && mapData) {\n        const viewport = viewportRef.current;\n        viewport.moveCenter(mapWidth / 2, mapHeight / 2);\n        console.log(\"hi\")\n    }\n  }, [mapData, mapHeight, mapWidth]);\n\n\n  if (!loadComplete || !mapData) {\n    return (\n      <div>Loading...</div>\n    )\n  }\n\n  const renderLayers = (layers: TiledLayerData[]) => {\n    return layers.filter(l => l.visible).map((layer: TiledLayerData) => {\n      return (\n        <Container key={layer.name} name={layer.name}>\n          {renderLayerTiles(layer.data)}\n        </Container>\n      )  \n    });\n  } \n\n  const renderLayerTiles = (tileData: number[]) => {\n    return tileData.map((gid, i) => {\n      const tileset = findTileset(gid, mapData!.tilesets);\n      if (!tileset || !tileset.tiles) return null;\n\n      const columns = mapData!.width;\n      const x = (i % columns);\n      const y = Math.floor(i / columns);\n      const texture = tileset.tiles.find((t) => t.id === gid - tileset.firstgid);\n      if (!texture) return null;\n\n      // the image is in the format \"tiles/structure-wall/tile-structure-wall-gray-left.png\"\n      // the 'structure-wall' part refers to the spritesheet, the 'tile-structure-wall-gray-left' is the texture on the spriesheet\n      const [\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        _,\n        spritesheet,\n        textureName\n      ] = texture.image.split(\"/\");\n      if (!tilesetsTextures[spritesheet]) {\n        console.warn(`Could not find spritesheet ${spritesheet} ${tilesetsTextures}`);\n      };\n      if (!tilesetsTextures[spritesheet][textureName]) {\n        console.warn(`Could not find texture ${spritesheet} ${textureName}`);\n      }\n      // tilesetsTextures[spritesheet][textureName].baseTexture.scaleMode = SCALE_MODES.NEAREST;\n      return (\n          <Sprite\n            key={i}\n            name={`${x},${y}`}\n            texture={tilesetsTextures[spritesheet][textureName]}\n            anchor={[0, 1]}\n            pivot={[TILE_WIDTH / 2, 0]}\n            position={tileLocationToPosition([x, y])}\n          /> \n      );  \n    })\n  }\n\n\n\n  const options = {\n    sharedLoader: true,\n    backgroundColor: 0xffffff\n  }\n  return (\n    <Stage width={screenWidth} height={screenHeight} className=\"background\" options={options}>\n      <Viewport\n        worldWidth={mapWidth}\n        worldHeight={mapHeight}\n        screenWidth={screenWidth}\n        screenHeight={screenHeight}\n        ref={viewportRef}\n      >\n       {renderLayers(mapData.layers)}\n      </Viewport>\n    </Stage>\n  );\n}\n\nexport default Map;\n\n// returns the path to the spritesheet for given tileset\nconst determineTilesetSpritesheetPath = (tilesetData: TiledTilesetData) => `${process.env.PUBLIC_URL}/maps/tilesets/${tilesetData.name}.json`;\n\n// finds tileset based on gid\nconst findTileset = (gid: number, tilesets: TiledTilesetData[]) => {\n  let tileset;\n  for (let i = tilesets.length - 1; i >= 0; i--) {\n    tileset = tilesets[i];\n    if (tileset.firstgid <= gid) {\n      break;\n    }\n  }\n  return tileset;\n}\n","import React, { useState } from 'react';\nimport './App.css';\nimport Map from \"./components/Map\";\n\n\nfunction App() {\n  const [currentMap, setCurrentMap] = useState(\"maps/testmap2.json\");\n  return (\n    <div className=\"App\">\n      <select value={currentMap} onChange={e => setCurrentMap(e.currentTarget.value)}>\n        <option>maps/testmap1.json</option>\n        <option>maps/testmap2.json</option>\n      </select>\n      <Map jsonPath={currentMap} />\n        {/* <Stage width={mapWidth} height={mapHeight} options={{backgroundColor: 0x0}} className=\"background\">\n            {textures && (\n              <>\n                <Sprite\n                  texture={textures[\"tile-structure-floor-blackwhite.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([0, 0])}\n                /> \n                <Sprite\n                  texture={textures[\"tile-structure-floor-blackwhite.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([1, 0])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-blackwhite.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([2, 0])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-blackwhite.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([3, 0])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-dadada.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([4, 0])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-blackwhite.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([5, 0])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-dadada.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([0, 1])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-wood.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([1, 1])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-blackwhite.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([2, 1])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([3, 1])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([4, 1])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([5, 1])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([0, 2])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([1, 2])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([2, 2])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([3, 2])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([4, 2])}\n                />\n                <Sprite\n                  texture={textures[\"tile-structure-floor-grass.png\"]}\n                  anchor={[.5, 1]}\n                  width={TILE_WIDTH}\n                  height={TILE_HEIGHT}\n                  position={tileLocationToPosition([5, 2])}\n                />\n              </> \n            )}\n\n        </Stage> */}\n        </div>\n  );\n}\n\nexport default App;\n\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}